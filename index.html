<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Euro 2024 Goals: Reversed Small Multiples + Direct Match Info</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      background-color: #fafafa;
      font-family: "Open Sans", sans-serif;
      margin: 0; padding: 0;
      color: #333;
    }
    h1 {
      text-align: center;
      margin: 1em 0 0.5em 0;
    }
    #controls {
      width: 900px;
      margin: 0 auto;
      text-align: center;
      margin-bottom: 1em;
    }
    select, input[type=checkbox] {
      margin: 0.5em;
    }
    /* Main timeline container */
    #mainTimelineContainer {
      width: 900px;
      margin: 0 auto;
      position: relative;
    }
    #goalsSvg {
      display: block;
      margin: 0 auto;
      background: #f0f0f0;
      border: 1px solid #ccc;
    }
    .heat-rect {
      stroke: none;
    }
    .goal-circle {
      stroke: #333;
      stroke-width: 1px;
      cursor: pointer;
    }
    .extra-time-line {
      stroke: black;
      stroke-width: 2px;
      stroke-dasharray: 3,3;
    }
    /* Tooltip */
    #tooltip {
      position: absolute;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      padding: 4px 8px;
      pointer-events: none;
      display: none; /* hidden by default */
      font-size: 0.9em;
      z-index: 10; /* ensure on top */
    }
    /* Small multiples container */
    #teamsContainer {
      width: 900px;
      margin: 2em auto;
      position: relative;
      overflow: visible;  /* Allow transformed content to be visible */
    }
    .team-chart-bg {
      fill: #eee;
      stroke: #ccc;
      stroke-width: 1px;
    }
    .team-label {
      font-size: 12px;
      text-anchor: end;  /* Right-align text */
      alignment-baseline: middle;
      font-weight: bold;
      cursor: help;  /* Show question mark cursor on hover */
    }
    .goal-count {
      font-size: 12px;
      text-anchor: start;  /* Left-align text */
      alignment-baseline: middle;
      fill: #666;
    }
    .mini-heat-rect {
      stroke: none;
    }
    #teamsSvg {
      display: block;
    }
    .heat-group {
      mix-blend-mode: multiply;
    }
    .mini-heat-rect {
      stroke: none;
      shape-rendering: geometricPrecision;
    }
    .half-time-line {
      stroke: black;
      pointer-events: none;
    }
    .extra-time-line {
      stroke: black;
      pointer-events: none;
    }
    .period-label {
      font-family: "Open Sans", sans-serif;
      font-size: 12px;
      color: #666;
      pointer-events: none;
    }
    #periodLabels {
      margin-bottom: 20px;
      position: relative;
    }
    #controls select {
      margin: 0 10px;
      padding: 2px 5px;
    }

    #sortSelect {
      min-width: 150px;  /* Give enough space for options */
    }

    #smallMultiplesControls {
      width: 900px;
      margin: 20px auto;
      text-align: center;
      padding: 10px 0;
      font-size: 14px;
    }

    #smallMultiplesControls select {
      margin-left: 10px;
      padding: 3px 8px;
      font-size: 14px;
    }

    /* Styles for highlighting/dimming */
    .team-goal.dimmed {
      opacity: 0.3;
    }

    .team-goal.highlighted {
      opacity: 1;
      stroke-width: 2px;
    }

    .team-chart-bg.spain-highlight {
      fill: #fff8f0;  /* Subtle warm background */
      stroke: #ff4500;  /* Match the heatmap color */
      stroke-width: 2px;
      stroke-opacity: 0.6;
    }

    .team-label.spain-highlight {
      fill: #ff4500;  /* Match the heatmap color */
      font-weight: 700;
    }

    #phaseTooltip {
      position: absolute;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ccc;
      padding: 8px 12px;
      pointer-events: none;
      display: none;
      font-size: 12px;
      z-index: 10;
      box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.1);
    }

    #storyNavigation {
      text-align: center;
      margin: 20px 0;
      padding: 10px;
      background: #f8f8f8;
      border-bottom: 1px solid #ddd;
    }

    #storyNavigation button {
      padding: 8px 16px;
      margin: 0 10px;
      font-size: 14px;
      cursor: pointer;
      border: 1px solid #666;
      background: white;
      border-radius: 4px;
    }

    #storyNavigation button:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }

    #slideIndicator {
      font-size: 14px;
      color: #666;
      padding: 0 20px;
    }

    .slide {
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }

    .slide.active {
      display: block;
      opacity: 1;
    }

    h2 {
      text-align: center;
      color: #333;
      margin: 20px 0;
    }

    /* Shot analysis styles */
    #shotControls {
      text-align: center;
      margin: 20px 0;
    }

    #shotControls label {
      margin: 0 15px;
    }

    #shotAnalysisContainer {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin: 20px auto;
      width: 900px;
    }

    #pitchViz {
      position: relative;
    }

    .shot-point {
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    .shot-point:hover {
      opacity: 1;
    }

    #shotTooltip {
      position: absolute;
      background: white;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 0;
      pointer-events: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      max-width: 300px;
      font-size: 12px;
      transition: opacity 0.2s;
    }

    .pitch-line {
      fill: none;
      stroke: #ccc;
      stroke-width: 1;
    }

    #legendContainer {
      text-align: center;
      margin: 20px 0;
    }

    .hexbin {
      pointer-events: none;  /* Make sure hexbins don't interfere with shot interactions */
    }
    
    .shots-group {
      pointer-events: all;
    }

    .filter-container {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin: 15px 0;
    }

    .shot-type-filters, .set-piece-filters {
      padding: 8px;
      background: #f8f8f8;
      border-radius: 5px;
      display: inline-flex;
      align-items: center;
    }

    .filter-label {
      font-weight: bold;
      margin-right: 15px;
    }

    .icon-filter {
      display: inline-flex;
      align-items: center;
      margin: 0 5px;  /* Reduced margin */
      cursor: pointer;
      padding: 3px 8px;  /* Reduced padding */
      border-radius: 4px;
      border: 1px solid #ddd;
      background: white;
      font-size: 12px;  /* Smaller font */
    }

    .icon-filter:hover {
      background: #f0f0f0;
    }

    .icon-filter input {
      display: none;
    }

    .icon-filter.active {
      background: #e3f2fd;
      border-color: #2196f3;
    }

    .icon {
      font-size: 1.2em;
      margin-right: 5px;
    }

    .view-options {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #ddd;
    }

    #teamGoalsContainer {
      width: 900px;
      margin: 40px auto;  /* Increased margin */
      padding: 20px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    #teamGoalsContainer h3 {
      margin-bottom: 20px;
      color: #333;
      text-align: center;
    }

    .team-goal-area {
      background: #f8f8f8;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .team-goal-label {
      font-size: 13px;
      font-weight: bold;
      fill: #333;
    }

    .team-goal-area.spain-highlight {
      fill: #fff8f0;  /* Subtle warm background */
      stroke: #ff4500;  /* Highlight color */
      stroke-width: 2px;
    }

    .team-goal-label.spain-highlight {
      fill: #ff4500;  /* Match the highlight color */
      font-weight: 700;
    }

    .team-hover-area:hover + .team-goal-area {
      filter: brightness(0.95);
    }

    #teamGoalsContainer {
      display: none;
    }

    #slide2.active #teamGoalsContainer {
      display: block;
    }

    .small-multiples-controls {
      text-align: center;
      margin-bottom: 15px;
      background: #f8f8f8;
      padding: 10px;
      border-radius: 5px;
    }

    .sort-label {
      font-weight: bold;
      margin-right: 15px;
    }

    .sort-option {
      margin: 0 10px;
      cursor: pointer;
      padding: 5px 10px;
      border-radius: 4px;
      background: white;
      border: 1px solid #ddd;
      display: inline-flex;
      align-items: center;
    }

    .sort-option:hover {
      background: #f0f0f0;
    }

    .sort-option input[type="radio"] {
      margin-right: 6px;
    }

    #playerAnalysisContainer {
      width: 900px;
      margin: 20px auto;
      padding: 20px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .analysis-section {
      margin: 20px 0;
    }

    .view-options {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      justify-content: center;  /* Center the options */
      border-top: 1px solid #ddd;
      padding-top: 15px;
      margin-top: 15px;
    }

    .view-option {
      padding: 8px 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      background: white;
    }

    .view-option:hover {
      background: #f0f0f0;
    }

    .view-option input {
      margin-right: 8px;
    }

    .view-section {
      display: none;
    }

    .view-section.active {
      display: block;
    }

    .scatter-controls {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
    }

    .scatter-controls select {
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }

    /* Add specific styling for shot controls view options */
    #shotControls .view-options {
      justify-content: center;
      border-top: 1px solid #ddd;
      padding-top: 15px;
      margin-top: 15px;
      width: 100%;  /* Ensure full width */
    }

    .sort-controls {
      text-align: center;
      margin-bottom: 20px;
      background: #f8f8f8;
      padding: 10px;
      border-radius: 5px;
    }

    .sort-option {
      margin: 0 10px;
      cursor: pointer;
      padding: 5px 10px;
      border-radius: 4px;
      background: white;
      border: 1px solid #ddd;
      display: inline-flex;
      align-items: center;
    }

    .sort-option:hover {
      background: #f0f0f0;
    }

    .sort-option input[type="radio"] {
      margin-right: 6px;
    }

    .metric-label {
      font-weight: bold;
      margin-right: 10px;
    }

    .scatter-controls {
      text-align: center;
      margin-bottom: 20px;
      background: #f8f8f8;
      padding: 10px;
      border-radius: 5px;
    }

    .scatter-controls select {
      padding: 5px 10px;
      border-radius: 4px;
      border: 1px solid #ddd;
      font-size: 14px;
      min-width: 150px;
    }

    .analysis-section {
      margin-bottom: 40px;
      padding: 20px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .player-tooltip {
      position: absolute;
      background: white;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 0;
      pointer-events: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      max-width: 300px;
      font-size: 12px;
      transition: opacity 0.2s;
    }

    .narrative-section {
      max-width: 800px;
      margin: 20px auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
      font-size: 16px;
    }

    .narrative-section p {
      margin-bottom: 1em;
    }

    .conclusion-section {
      max-width: 800px;
      margin: 40px auto;
      padding: 30px;
      background: #f8f8f8;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .conclusion-section h2 {
      color: #333;
      margin-bottom: 20px;
    }

    .conclusion-section p {
      line-height: 1.8;
      font-size: 16px;
      color: #444;
    }

  </style>
</head>
<body>

<h1>How did Spain win the 2024 euros: A data view</h1> 

<div id="storyNavigation">
  <button id="prevSlide" disabled>← Previous</button>
  <span id="slideIndicator">1 / 7</span>
  <button id="nextSlide">Next →</button>
    </div>

<div id="slides">
  <div id="slide1" class="slide active">
    <h2>Goals Timeline Analysis</h2>
    <div class="narrative-section">
      <p>
        Spain's triumph in Euro 2024 marked their fourth European Championship victory, showcasing a blend of tactical brilliance and clinical finishing. 
        Their journey through the tournament was characterized by crucial goals at pivotal moments, demonstrating both their ability to control games 
        and their resilience under pressure.
      </p>
      <p>
        Let's begin by examining the timing of Spain's goals throughout the tournament, revealing patterns in their scoring and how they compared 
        to other teams. The timeline below shows when goals were scored, highlighting the moments that shaped their path to victory.
      </p>
  </div>
    <div id="controls">
      <label>Team Filter:</label>
      <select id="teamSelect"></select>

      <label>
        <input type="checkbox" id="penaltyCheck" />
        Exclude Penalty Goals
      </label>

      <label>
        <input type="checkbox" id="miniHeatCheck" />
        Heatmap in Small Multiples
      </label>
    </div>

    <div id="mainTimelineContainer">
      <svg id="goalsSvg" width="900" height="300"></svg>
      <div id="tooltip"></div>
  </div>

    <div id="smallMultiplesControls">
      <label>Sort Small Multiples by:</label>
      <select id="sortSelect">
        <option value="total">Total Goals</option>
        <option value="penalty">Penalty Goals</option>
        <option value="extraTime">Extra Time Goals</option>
        <option value="nonPenalty">Goals (Excluding Penalties)</option>
      </select>
  </div>

    <div id="teamsContainer">
      <!-- teamsSvg will be inserted here -->
    </div>

    <div id="phaseTooltip"></div>
  </div>

  <div id="slide2" class="slide">
    <h2>Shot Analysis & Outcomes</h2>
     <div class="narrative-section">
      <p>
        Another interesting thing was how Spain approached scoring goals, which is.different than others and with a lot of shorts and a lot of expected goals. Spain came out on top. Let'slook at this comparison between Spain and other teams between the total goals expected goals and total charts to see.how the scene was set.
      </p>
      
  </div>
    <div id="shotControls">
      <label style="margin-right: 20px;">
        Team: 
        <select id="shotTeamSelect">
          <option value="all">All Teams</option>
        </select>
      </label>

      <div class="filter-container">
        <div class="shot-type-filters">
          <span class="filter-label">Shot Type:</span>
          <label class="icon-filter">
            <input type="checkbox" value="right_foot" checked>
            <span class="icon">👟</span>
            <span class="label">Right</span>
          </label>
          <label class="icon-filter">
            <input type="checkbox" value="left_foot" checked>
            <span class="icon">👟</span>
            <span class="label">Left</span>
          </label>
          <label class="icon-filter">
            <input type="checkbox" value="header" checked>
            <span class="icon">👤</span>
            <span class="label">Head</span>
          </label>
    </div>

        <div class="set-piece-filters">
          <span class="filter-label">Set Pieces:</span>
          <label class="icon-filter">
            <input type="checkbox" value="penalty" checked>
            <span class="icon">⚽</span>
            <span class="label">Pen</span>
          </label>
          <label class="icon-filter">
            <input type="checkbox" value="free_kick" checked>
            <span class="icon">🎯</span>
            <span class="label">FK</span>
          </label>
    </div>
  </div>

      <div class="view-options">
        <label style="margin-right: 20px;">
          <input type="checkbox" name="shotType" value="shots" checked>
          Show Non-Goal Shots
        </label>
        <label style="margin-right: 20px;">
          <input type="checkbox" id="showDirections" checked>
          Show Shot Directions
        </label>
        <label>
          <input type="checkbox" id="showXG" checked>
          Size by Expected Goals (xG)
        </label>
      </div>
    </div>

    <div id="shotAnalysisContainer">
      <div id="pitchViz">
        <svg id="shotMapSvg" width="800" height="600"></svg>
        <div id="shotTooltip" class="tooltip"></div>
      </div>
    </div>

    <div id="teamGoalsContainer">
      <div class="small-multiples-controls">
        <span class="sort-label">Sort by:</span>
        <label class="sort-option">
          <input type="radio" name="teamSort" value="goals" checked>
          Total Goals
        </label>
        <label class="sort-option">
          <input type="radio" name="teamSort" value="xg">
          Expected Goals
        </label>
        <label class="sort-option">
          <input type="radio" name="teamSort" value="shots">
          Total Shots
        </label>
      </div>
      <h3>Goals by Team</h3>
      <svg id="teamGoalsSvg"></svg>
    </div>
  </div>

  <div id="slide3" class="slide">
    <h2>Player Composition and contributions</h2>
    <div class="narrative-section">
      <p>
       Market value of players clearly reflected a good correlation with the final standing.but talking about clear contribution with the data we have, we can say that it was not individual trillions, but a well structured team and well structured tactics that led Spain to its victory.
      </p>
      
  </div>
    <div id="playerAnalysisContainer">
      <!-- Market Value Section -->
      <div class="analysis-section">
        <div class="sort-controls">
          <span class="sort-label">Sort by:</span>
          <label class="sort-option">
            <input type="radio" name="marketSort" value="value" checked>
            Market Value
          </label>
          <label class="sort-option">
            <input type="radio" name="marketSort" value="standings">
            Final Standings
          </label>
        </div>
        <svg id="marketValueSvg"></svg>
      </div>

      <!-- Player Contribution Scatter Plot Section -->
      <div class="analysis-section">
        <h2>Player contributions</h2>
        <div id="scatterControls" class="sort-controls">
          <!-- Team filter will be inserted here -->
        </div>
        <svg id="contributionScatterSvg"></svg>
      </div>
    </div>
  </div>
  <script>
/**
 * We'll load subset_euro_2024.json:
 *  - Filter for shot_outcome == "Goal".
 *  - For each event, we assume fields:
 *    d.player -> the scorer
 *    d.home_team, d.away_team -> teams playing
 *    d.home_score, d.away_score -> final scores
 *    shot_type -> "Penalty" or something else
 *  - We'll clamp timeInMin in [0..130] for binning, domain extends -5..135
 *  - Exclude Penalty is ON by default
 *  - We have small multiples sorted by total goals, each row reversed horizontally
 */

const svg = d3.select("#goalsSvg");
const tooltip = d3.select("#tooltip");
      const width = +svg.attr("width");
      const height = +svg.attr("height");

const margin = { top: 20, right: 20, bottom: 30, left: 40 };
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;

const gMain = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

// We'll define an extended domain: e.g. -5..135
const xDomain = [-5, 135];
const xScale = d3.scaleLinear()
  .domain(xDomain)
  .range([0, innerWidth]);

// Center for circles in main chart
const yCenter = innerHeight / 2;

// We'll store allGoals, allTeams
let allGoals = [];
let allTeams = [];

// DOM references for filters
const teamSelectEl = document.getElementById("teamSelect");
const penaltyCheckEl = document.getElementById("penaltyCheck");
const miniHeatCheckEl = document.getElementById("miniHeatCheck");

// Set "Exclude Penalty Goals" ON by default
penaltyCheckEl.checked = true;

let teamsSvg; // we'll build once for small multiples

// Add DOM reference for sort select
const sortSelectEl = document.getElementById("sortSelect");

// Add this after your existing variable declarations
const totalSlides = 3;  // Changed from 2 to 3
let currentSlide = 1;

// Add navigation controls
const prevSlide = document.getElementById("prevSlide");
const nextSlide = document.getElementById("nextSlide");
const slideIndicator = document.getElementById("slideIndicator");

function updateNavigation() {
  prevSlide.disabled = currentSlide === 1;
  nextSlide.disabled = currentSlide === totalSlides;
  slideIndicator.textContent = `${currentSlide} / ${totalSlides}`;
}

function goToSlide(slideNumber) {
  // Hide current slide
  document.querySelector(`.slide.active`).classList.remove("active");
  
  // Show new slide
  document.querySelector(`#slide${slideNumber}`).classList.add("active");
  
  // Update current slide number
  currentSlide = slideNumber;
  
  // Update navigation
  updateNavigation();

  // Load appropriate data for each slide
  if (slideNumber === 2 && allEvents) {
    renderShotAnalysis();
  } else if (slideNumber === 3) {
    loadPlayerData();
  }
}

// Add event listeners for navigation
prevSlide.addEventListener("click", () => {
  if (currentSlide > 1) goToSlide(currentSlide - 1);
});

nextSlide.addEventListener("click", () => {
  if (currentSlide < totalSlides) goToSlide(currentSlide + 1);
});

// Initialize navigation
updateNavigation();

// Update your data loading section
let allEvents; // Add this with your other global variables

      d3.json("subset_euro_2024.json").then(events => {
  allEvents = events; // Store all events for use in other slides
  
  // Filter for shot_outcome = "Goal"
        const goals = events.filter(d => d.type === "Shot" && d.shot_outcome === "Goal");

  // For each, compute timeInMin + clamp for binning in [0..130]
        goals.forEach(d => {
    const rawTime = (d.minute || 0) + ((d.second||0)/60);
    d.clampedMinute = Math.max(0, Math.min(130, rawTime));
    d.timeInMin = rawTime; // can display up to 135
  });

  // Build set of teams
  const teamSet = new Set(goals.map(d => d.team));
  allTeams = Array.from(teamSet).sort();

  // Populate <select>
  let optAll = document.createElement("option");
  optAll.value = "All";
  optAll.text = "All Teams";
  teamSelectEl.appendChild(optAll);

  allTeams.forEach(t => {
    const opt = document.createElement("option");
    opt.value = t;
    opt.text = t;
    teamSelectEl.appendChild(opt);
  });

  allGoals = goals;

  // Build small multiples container
  buildTeamSmallMultiples();

  // Attach listeners => re-draw main timeline + small multiples
  teamSelectEl.addEventListener("change", updateAll);
  penaltyCheckEl.addEventListener("change", updateAll);
  miniHeatCheckEl.addEventListener("change", updateAll);
  sortSelectEl.addEventListener("change", updateAll);

  // Initial draw
  updateAll();
});


function updateAll() {
  // Re-draw main timeline + small multiples
  updateMainChart();
  updateTeamSmallMultiples();
}


/**
 * updateMainChart():
 *  - Applies team filter + penalty filter
 *  - Re-draws heatmap bins + circles
 */
function updateMainChart() {
  gMain.selectAll("*").remove();

  const selectedTeam = teamSelectEl.value;
  const excludePen = penaltyCheckEl.checked;

  // Filter
  let filtered = allGoals;
  if(selectedTeam !== "All") {
    filtered = filtered.filter(d => d.team === selectedTeam);
  }
  if(excludePen) {
    filtered = filtered.filter(d => d.shot_type !== "Penalty");
  }

  // Build bins for minuteCounts[0..130]
  const minuteCounts = new Array(131).fill(0);
  filtered.forEach(d => {
    const m = Math.floor(d.clampedMinute);
    minuteCounts[m]++;
  });
  const maxCount = d3.max(minuteCounts) || 0;

  // Color scale for heatmap
  const heatColor = d3.scaleLinear()
    .domain([0, maxCount])
    .range(["#ffffff", "#ff4500"]);

  // We'll create 131 bins => i=0..130
  const binWidth = xScale(1) - xScale(0);

  // 1) Heatmap
  gMain.selectAll(".heat-rect")
    .data(minuteCounts)
    .enter().append("rect")
      .attr("class", "heat-rect")
      .attr("x", (count, i) => xScale(i))
      .attr("y", 0)
      .attr("width", binWidth+0.5)
      .attr("height", innerHeight)
      .attr("fill", c => heatColor(c));

  // 2) X-axis
        const xAxis = d3.axisBottom(xScale)
    .tickFormat(d => d + "'")
    .ticks(14);
  gMain.append("g")
    .attr("transform", `translate(0,${innerHeight})`)
          .call(xAxis);

  // 3) Vertical line at 90
  const x90 = xScale(90);
  gMain.append("line")
    .attr("class", "extra-time-line")
    .attr("x1", x90)
    .attr("y1", 0)
    .attr("x2", x90)
    .attr("y2", innerHeight);

  // Add half-time line at 45'
  const x45 = xScale(45);
  gMain.append("line")
    .attr("class", "half-time-line")
    .attr("x1", x45)
    .attr("y1", 0)
    .attr("x2", x45)
    .attr("y2", innerHeight)
    .attr("stroke", "black")
    .attr("stroke-width", 1.5)
    .attr("stroke-dasharray", "5,5");

  // 4) Circles
  const colorScale = d3.scaleOrdinal()
    .domain(allTeams)
    .range(d3.schemeCategory10);

  gMain.selectAll(".goal-circle")
    .data(filtered)
          .enter().append("circle")
            .attr("class", "goal-circle")
            .attr("cx", d => xScale(d.timeInMin))
      .attr("cy", () => (innerHeight/2) + (Math.random()*10 - 5))
      .attr("r", 5)
            .attr("fill", d => colorScale(d.team))
            .on("mouseover", (event, d) => {
        showTooltip(event, d);
      })
      .on("mouseout", hideTooltip);
}


/**
 * buildTeamSmallMultiples():
 *  Creates an empty SVG for small multiples. We'll re-build rows on each update.
 */
function buildTeamSmallMultiples() {
  const container = d3.select("#teamsContainer");
  container.selectAll("*").remove();

  // Set the container width to match main timeline
  container.style("width", width + "px");

  teamsSvg = container.append("svg")
    .attr("id", "teamsSvg")
    .style("margin", "0 auto")  // Center horizontally
    .style("display", "block"); // Ensure block display
}


/**
 * updateTeamSmallMultiples():
 *  - Sort teams by total goals desc
 *  - Re-build rows in that order
 *  - Each row: label on left, circles on the RIGHT side => reversed x-scale
 */
function updateTeamSmallMultiples() {
  teamsSvg.selectAll("*").remove();

  // Remove any existing period labels first
  d3.select("#periodLabels").remove();

  const excludePen = penaltyCheckEl.checked;
  const showHeatInMini = miniHeatCheckEl.checked;

  // Count goals per team under current filters
  let teamGoalsCount = [];
  allTeams.forEach(team => {
    let allTeamGoals = allGoals.filter(d => d.team === team);
    let penaltyGoals = allTeamGoals.filter(d => d.shot_type === "Penalty").length;
    let nonPenaltyGoals = allTeamGoals.filter(d => d.shot_type !== "Penalty").length;
    let extraTimeGoals = allTeamGoals.filter(d => d.timeInMin >= 90).length;
    
    teamGoalsCount.push({ 
      team, 
      total: allTeamGoals.length,
      penaltyGoals,
      nonPenaltyGoals,
      extraTimeGoals,
      // Dynamic sort value based on selected sort option
      sortValue: getSortValue(allTeamGoals, penaltyGoals, nonPenaltyGoals, extraTimeGoals)
    });
  });
  
  // Sort by the dynamic sortValue
  teamGoalsCount.sort((a, b) => d3.descending(a.sortValue, b.sortValue));

  // Calculate the exact dimensions from the main chart
  const mainChartStart = margin.left;
  const minute130Position = xScale(130);
  const mainChartWidth = minute130Position - mainChartStart;

  // Additional offsets for labels (but don't affect graph alignment)
  const labelOffset = {
    left: 80,
    right: 40
  };

  const chartWidth = width;
  const chartHeight = 60;
  const spacing = 10;
  const totalHeight = teamGoalsCount.length * (chartHeight + spacing) + 20;
  
  // Set the SVG width to include label spaces but position content relative to main chart
  const totalWidth = width + labelOffset.left + labelOffset.right;
  
  // Set container width to match main chart width
  d3.select("#teamsContainer")
    .style("width", width + "px")
    .style("margin", "0 auto")
    .style("position", "relative");

  // Center the SVG by adjusting its position
  teamsSvg
    .attr("width", totalWidth)
    .attr("height", totalHeight)
    .style("margin", "0 auto")
    .style("transform", `translateX(${-labelOffset.left/2}px)`);  // Shift left by half the label offset

  // Use scale that ends exactly at minute 130
  const xScaleSmall = d3.scaleLinear()
    .domain(xDomain)
    .range([mainChartStart, mainChartStart + minute130Position - mainChartStart]);  // End at minute 130

  const colorScale = d3.scaleOrdinal()
    .domain(allTeams)
    .range(d3.schemeCategory10);

  // Add period labels in a separate container
  const labelContainer = d3.select("#teamsContainer")
    .insert("div", "#teamsSvg")
    .attr("id", "periodLabels")
    .style("position", "relative")
    .style("height", "30px")
    .style("width", width + "px")
    .style("margin", "25px auto 15px auto");

  // Center the period labels container
  labelContainer
    .style("width", width + "px")
    .style("margin", "25px auto 15px auto")  // Add more top padding
    .style("transform", `translateX(${-labelOffset.left/2}px)`);

  // Calculate positions based on the main chart scale
  const firstHalfX = margin.left;  // Start of chart
  const secondHalfX = margin.left + xScale(45);  // 45-minute mark
  const extraTimeX = margin.left + xScale(90);   // 90-minute mark
  const chartEndX = margin.left + xScale(130);   // End of chart

  // Add the period labels
  const labels = [
    { text: "First Half", x: firstHalfX, width: secondHalfX - firstHalfX },
    { text: "Second Half", x: secondHalfX, width: extraTimeX - secondHalfX },
    { text: "Extra Time", x: extraTimeX, width: chartEndX - extraTimeX }
  ];

  labels.forEach(label => {
    labelContainer.append("div")
      .style("position", "absolute")
      .style("left", label.x + "px")
      .style("width", label.width + "px")
      .style("text-align", "center")
      .style("font-size", "12px")
      .style("color", "#666")
      .style("top", "0")
      .text(label.text);
  });

  function shouldHighlight(d) {
    const sortType = sortSelectEl.value;
    if (sortType === "total") return "normal";  // Normal state
    if (sortType === "penalty") return d.shot_type === "Penalty" ? "highlight" : "dim";
    if (sortType === "extraTime") return (d.timeInMin >= 90 && d.shot_type !== "Penalty") ? "highlight" : "dim";
    if (sortType === "nonPenalty") return d.shot_type !== "Penalty" ? "highlight" : "dim";
    return "normal";
  }

  teamGoalsCount.forEach((obj, i) => {
    const { team, total, penaltyGoals } = obj;
    const yOffset = i * (chartHeight + spacing) + 10;
    const isSpain = team === "Spain";  // Check if this is Spain's row

    const subG = teamsSvg.append("g")
      .attr("transform", `translate(${labelOffset.left},${yOffset})`);

    // Background rect - add special class for Spain
    subG.append("rect")
      .attr("class", `team-chart-bg ${isSpain ? 'spain-highlight' : ''}`)
      .attr("width", mainChartWidth)
      .attr("height", chartHeight)
      .attr("x", mainChartStart)
      .attr("y", 0)
      .attr("fill", "#f0f0f0");

    // Team name on the left with hover stats
    const phaseTooltip = d3.select("#phaseTooltip");
    const teamLabel = subG.append("text")
      .attr("class", `team-label ${isSpain ? 'spain-highlight' : ''}`)
      .attr("x", mainChartStart - 10)
      .attr("y", chartHeight/2)
      .attr("text-anchor", "end")
      .attr("dominant-baseline", "middle")
      .text(team)
      .on("mouseover", (event) => {
        const stats = getPhaseStats(allGoals.filter(d => d.team === team));
        const content = `
          <strong>${team}</strong><br>
          First Half: ${stats.firstHalf}%<br>
          Second Half: ${stats.secondHalf}%<br>
          Extra Time: ${stats.extraTime}%
        `;
        
        phaseTooltip
          .html(content)
          .style("display", "block")
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY - 10) + "px");
      })
      .on("mouseout", () => {
        phaseTooltip.style("display", "none");
      });

    // Update the goal count text logic
    const goalText = (!excludePen && penaltyGoals > 0) ? 
      `${total} Goals (${penaltyGoals} Penalty)` : 
      `${excludePen ? obj.nonPenaltyGoals : total} Goals`;

    subG.append("text")
      .attr("class", "goal-count")
      .attr("x", mainChartStart + mainChartWidth + 10)
      .attr("y", chartHeight/2)
      .attr("text-anchor", "start")
      .attr("dominant-baseline", "middle")
      .text(goalText);

    // Filter goals for this team
    let rowGoals = allGoals.filter(d => d.team === team);
    if(excludePen) {
      rowGoals = rowGoals.filter(d => d.shot_type !== "Penalty");
    }

    if(showHeatInMini) {
      // Create more granular bins for smoother heatmap
      const minuteCounts = new Array(261).fill(0);  // Double the resolution
      
      // Count goals with more granular binning and stronger spread
      rowGoals.forEach(d => {
        const m = Math.floor(d.clampedMinute * 2);  // Double resolution
        // Spread the influence further with stronger weights
        for(let i = Math.max(0, m-4); i <= Math.min(260, m+4); i++) {
          const distance = Math.abs(m - i);
          // Exponential decay for smoother spread
          minuteCounts[i] += Math.exp(-distance * 0.5);  // Slower decay for wider spread
        }
      });

      const maxCount = d3.max(minuteCounts) || 0;
      
      // Use a more sensitive color scale with power scale for better visibility of low values
      const heatColor = d3.scaleSequential()
        .domain([0, maxCount * 0.7])  // Compress the range to make colors more visible
        .interpolator(t => d3.interpolateRgb("#ffffff", "#ff4500")(Math.pow(t, 0.4)));  // Reduced power for less intensity

      // White background
      const heatGroup = subG.append("g")
        .attr("class", "heat-group");

      heatGroup.append("rect")
        .attr("x", mainChartStart)
        .attr("y", 0)
        .attr("width", mainChartWidth)
        .attr("height", chartHeight)
        .attr("fill", "#ffffff");

      // Smaller bins for smoother appearance
      const binWidth = (xScaleSmall(0.5) - xScaleSmall(0));  // Half-minute bins
      
      heatGroup.selectAll(".mini-heat-rect")
        .data(minuteCounts)
        .enter().append("rect")
          .attr("class", "mini-heat-rect")
          .attr("x", (count, i) => xScaleSmall(i/2))
          .attr("y", 0)
          .attr("width", binWidth + 0.5)
          .attr("height", chartHeight)
          .attr("fill", c => heatColor(c))
          .attr("opacity", 0.4);  // Reduced opacity from 0.9 to 0.6
    }

    // Goals circles with highlighting
    const yCenter = chartHeight/2;
    subG.selectAll(".team-goal")
      .data(rowGoals)
      .enter().append("circle")
        .attr("class", d => {
          const state = shouldHighlight(d);
          return `team-goal ${state === "dim" ? "dimmed" : ""}`;
        })
        .attr("r", 4)
        .attr("fill", colorScale(team))
            .attr("stroke", "#333")
        .attr("stroke-width", d => {
          const state = shouldHighlight(d);
          return state === "highlight" ? 2 : 1;
        })
        .attr("cx", d => xScaleSmall(d.timeInMin))
        .attr("cy", () => yCenter + (Math.random()*6 - 3))
            .on("mouseover", (event, d) => {
          showTooltip(event, d);
        })
        .on("mouseout", hideTooltip);

    // Add half-time line at 45' (with lower opacity)
    const x45 = xScaleSmall(45);
    subG.append("line")
      .attr("class", "half-time-line")
      .attr("x1", x45)
      .attr("y1", 0)
      .attr("x2", x45)
      .attr("y2", chartHeight)
      .attr("stroke", "black")
      .attr("stroke-width", 1)
      .attr("stroke-dasharray", "4,4")
      .attr("opacity", 0.3);

    // Add extra-time line at 90' (with lower opacity)
    const x90 = xScaleSmall(90);
    subG.append("line")
      .attr("class", "extra-time-line")
      .attr("x1", x90)
      .attr("y1", 0)
      .attr("x2", x90)
      .attr("y2", chartHeight)
      .attr("stroke", "black")
      .attr("stroke-width", 1.5)
      .attr("stroke-dasharray", "3,3")
      .attr("opacity", 0.3);
  });
}

// Helper function to get sort value based on selected option
function getSortValue(goals, penalties, nonPenalties, extraTime) {
  const sortType = sortSelectEl.value;
  switch(sortType) {
    case "penalty":
      return penalties;
    case "extraTime":
      // Only count non-penalty goals in extra time
      return goals.filter(d => d.timeInMin >= 90 && d.shot_type !== "Penalty").length;
    case "nonPenalty":
      return nonPenalties;
    case "total":
    default:
      return goals.length;
  }
}

// Add this function to calculate phase percentages
function getPhaseStats(goals) {
  const total = goals.length;
  if (total === 0) return { firstHalf: 0, secondHalf: 0, extraTime: 0 };
  
  const firstHalf = goals.filter(d => d.timeInMin < 45).length;
  const secondHalf = goals.filter(d => d.timeInMin >= 45 && d.timeInMin < 90).length;
  const extraTime = goals.filter(d => d.timeInMin >= 90).length;
  
  return {
    firstHalf: (firstHalf / total * 100).toFixed(1),
    secondHalf: (secondHalf / total * 100).toFixed(1),
    extraTime: (extraTime / total * 100).toFixed(1)
  };
}

/**
 * showTooltip(event, d):
 *  - Positions the tooltip near the cursor
 *  - If near right edge, shift left
 *  - Content includes team, minute, match info from event data
 *    We assume:
 *      d.player -> scorer
 *      d.home_team, d.away_team -> e.g. "Switzerland", "Belgium"
 *      d.home_score, d.away_score -> final numeric scores
 */
function showTooltip(event, d) {
  // Attempt to build match label from the event itself
  const home = d.home_team || "HomeTeam";
  const away = d.away_team || "AwayTeam";
  const matchLabel = `${home} vs ${away}`;

  // final score
  const homeSc = (d.home_score != null) ? d.home_score : "?";
  const awaySc = (d.away_score != null) ? d.away_score : "?";
  const finalScore = `${homeSc}-${awaySc}`;

  const scorer = d.player || "Unknown Scorer";

  const content = `
    <strong>${d.team}</strong><br>
    Minute: ${d.timeInMin.toFixed(1)}<br>
    Match: ${matchLabel}<br>
    Final Score: ${finalScore}<br>
    Scorer: ${scorer}
  `;
  tooltip.html(content);

  let leftPos = event.pageX + 10;
  let topPos = event.pageY - 20;

  tooltip.style("display", "block")
    .style("left", leftPos + "px")
    .style("top", topPos + "px");

  const tipNode = tooltip.node();
  const tipWidth = tipNode.offsetWidth || 150;
  const tipHeight = tipNode.offsetHeight || 50;

  // If going off right edge
  if(leftPos + tipWidth > window.innerWidth) {
    leftPos = window.innerWidth - tipWidth - 10;
  }
  // If going off top
  if(topPos < 0) {
    topPos = 10;
  }
  tooltip.style("left", leftPos + "px")
         .style("top", topPos + "px");
}

function hideTooltip() {
  tooltip.style("display", "none");
}

// First, add this CSS rule to align the containers
function addCenteringCSS() {
  const style = document.createElement('style');
  style.textContent = `
    #mainTimelineContainer, #teamsContainer {
      width: ${width}px;
      margin: 0 auto;
      position: relative;
    }
    #teamsSvg {
      display: block;
      margin-left: ${-labelOffset.left}px;  /* Offset the extra width */
    }
  `;
  document.head.appendChild(style);
}

// Update the sort select event listener to handle penalty checkbox
sortSelectEl.addEventListener("change", (event) => {
  // If sorting by penalties, uncheck "Exclude Penalties"
  if (event.target.value === "penalty") {
    penaltyCheckEl.checked = false;
  }
  updateAll();
});

// First, add these scales for the pitch coordinates
const PITCH_LENGTH = 120;
const PITCH_WIDTH = 80;
const BOX_LENGTH = 16.5;
const BOX_WIDTH = 40.3;
const GOAL_WIDTH = 7.32;
const PENALTY_SPOT = 11;
const CIRCLE_RADIUS = 9.15;

function drawPitch(svg) {
  const width = +svg.attr("width");
  const height = +svg.attr("height");
  
  // Calculate margins to center the pitch
  const margin = {
    top: 40,
    bottom: 40,
    left: 60,
    right: 60
  };

  const pitchWidth = width - margin.left - margin.right;
  const pitchHeight = height - margin.top - margin.bottom;
  
  // Center the visualization
  const pitch = svg.append("g")
    .attr("class", "pitch")
    .attr("transform", `translate(${margin.left},${margin.top})`);

  // Create scales for full pitch
  window.xPitchScale = d3.scaleLinear()
    .domain([0, PITCH_LENGTH])
    .range([0, pitchWidth]);
  
  window.yPitchScale = d3.scaleLinear()
    .domain([0, PITCH_WIDTH])
    .range([0, pitchHeight]);

  // Draw pitch outline
  pitch.append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", pitchWidth)
    .attr("height", pitchHeight)
    .attr("fill", "#f8f8f8")
    .attr("stroke", "#666")
    .attr("stroke-width", 2);

  // Draw halfway line
  pitch.append("line")
    .attr("x1", pitchWidth/2)
    .attr("y1", 0)
    .attr("x2", pitchWidth/2)
    .attr("y2", pitchHeight)
    .attr("stroke", "#666")
    .attr("stroke-width", 1);

  // Draw center circle
  pitch.append("circle")
    .attr("cx", pitchWidth/2)
    .attr("cy", pitchHeight/2)
    .attr("r", xPitchScale(CIRCLE_RADIUS))
    .attr("fill", "none")
    .attr("stroke", "#666")
    .attr("stroke-width", 1);

  // Draw penalty boxes
  // Left penalty box
  pitch.append("rect")
    .attr("x", 0)
    .attr("y", (pitchHeight - yPitchScale(BOX_WIDTH))/2)
    .attr("width", xPitchScale(BOX_LENGTH))
    .attr("height", yPitchScale(BOX_WIDTH))
    .attr("fill", "none")
    .attr("stroke", "#666")
    .attr("stroke-width", 1);

  // Right penalty box
  pitch.append("rect")
    .attr("x", pitchWidth - xPitchScale(BOX_LENGTH))
    .attr("y", (pitchHeight - yPitchScale(BOX_WIDTH))/2)
    .attr("width", xPitchScale(BOX_LENGTH))
    .attr("height", yPitchScale(BOX_WIDTH))
    .attr("fill", "none")
    .attr("stroke", "#666")
    .attr("stroke-width", 1);

  // Draw penalty spots
  pitch.append("circle")
    .attr("cx", xPitchScale(PENALTY_SPOT))
    .attr("cy", pitchHeight/2)
    .attr("r", 2)
    .attr("fill", "#666");

  pitch.append("circle")
    .attr("cx", pitchWidth - xPitchScale(PENALTY_SPOT))
    .attr("cy", pitchHeight/2)
    .attr("r", 2)
    .attr("fill", "#666");

  return pitch;  // Return the pitch group for adding elements
}

function drawHeatmap(svg, data) {
  const hexbin = d3.hexbin()
    .x(d => xPitchScale(d.x))
    .y(d => yPitchScale(d.y))
    .radius(12)  // Adjust radius for better visualization
    .extent([[0, 0], [width - 120, height - 80]]);  // Adjust extent to match pitch

  const bins = hexbin(data);
  const maxCount = d3.max(bins, d => d.length);

  const colorScale = d3.scaleSequential()
    .domain([0, maxCount])
    .interpolator(d3.interpolateYlOrRd);

  svg.selectAll(".hexbin")
    .data(bins)
    .join("path")
    .attr("class", "hexbin")
    .attr("d", hexbin.hexagon())
    .attr("transform", d => `translate(${d.x},${d.y})`)
    .attr("fill", d => colorScale(d.length))
    .attr("opacity", 0.6);
}

function drawShotDirection(d) {
  const startX = xPitchScale(d.x);
  const startY = yPitchScale(d.y);
  const goalX = d.x > PITCH_LENGTH/2 ? PITCH_LENGTH : 0;  // Choose nearest goal
  const goalY = PITCH_WIDTH/2;
  
  // Calculate angle and length
  const dx = xPitchScale(goalX) - startX;
  const dy = yPitchScale(goalY) - startY;
  const angle = Math.atan2(dy, dx);
  const arrowLength = 20;
  
  // Calculate end point
  const endX = startX + arrowLength * Math.cos(angle);
  const endY = startY + arrowLength * Math.sin(angle);
  
  return `M ${startX},${startY} L ${endX},${endY}`;
}

function renderShotAnalysis() {
  const shotMapSvg = d3.select("#shotMapSvg")
    .attr("width", 800)
    .attr("height", 600);
    
  // Clear existing content
  shotMapSvg.selectAll("*").remove();
  
  // Draw the pitch and store reference globally
  window.pitch = drawPitch(shotMapSvg);

  // Add arrow marker for shot directions
  shotMapSvg.append("defs").append("marker")
    .attr("id", "arrow")
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 8)
    .attr("refY", 0)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
    .append("path")
    .attr("d", "M0,-5L10,0L0,5")
    .attr("fill", "#666");

  // Populate team select
  const shotTeamSelect = d3.select("#shotTeamSelect");
  const teams = [...new Set(allEvents.filter(d => d.type === "Shot").map(d => d.team))].sort();
  
  shotTeamSelect.selectAll("option.team")
    .data(teams)
    .enter()
    .append("option")
    .attr("class", "team")
    .attr("value", d => d)
    .text(d => d);

  // Add event listeners for all filters
  d3.selectAll('.icon-filter input').on("change", function() {
    const checkbox = d3.select(this);
    const label = d3.select(checkbox.node().closest('.icon-filter'));
    label.classed("active", checkbox.property("checked"));
    updateShots();
  });

  // Add event listeners for other controls
  d3.select('#shotTeamSelect').on("change", updateShots);
  d3.select('input[value="shots"]').on("change", updateShots);
  d3.select('#showDirections').on("change", updateShots);
  d3.select('#showXG').on("change", updateShots);

  // Initial render
  updateShots();
}

function updateShots() {
  if (!window.pitch) return;  // Guard against missing pitch reference

  // Clear existing elements
  window.pitch.selectAll(".shot-point, .shot-direction, .shot-group").remove();

  // Get filter states
  const showNonGoals = d3.select('input[value="shots"]').property('checked');
  const selectedTeam = d3.select('#shotTeamSelect').property('value');
  const showDirections = d3.select('#showDirections').property('checked');
  const showXG = d3.select('#showXG').property('checked');

  // Get active shot types and set pieces
  const activeTypes = Array.from(document.querySelectorAll('.icon-filter input:checked'))
    .map(input => input.value);

  // Filter data
  const shots = allEvents.filter(d => {
    if (d.type !== "Shot") return false;
    if (selectedTeam !== "all" && d.team !== selectedTeam) return false;
    
    // Check if shot type/body part is in active filters
    const shotTypeMatch = activeTypes.some(type => {
      if (type === "penalty" && d.shot_type === "Penalty") return true;
      if (type === "free_kick" && d.shot_type === "Free Kick") return true;
      if (type === "right_foot" && d.shot_body_part === "Right Foot") return true;
      if (type === "left_foot" && d.shot_body_part === "Left Foot") return true;
      if (type === "header" && d.shot_body_part === "Head") return true;
      return false;
    });

    if (!shotTypeMatch && activeTypes.length > 0) return false;
    if (d.shot_outcome === "Goal") return true;
    return showNonGoals;
  });

  // Create a group for each shot
  const shotGroups = window.pitch.selectAll(".shot-group")
    .data(shots)
    .join("g")
    .attr("class", "shot-group");

  // Add direction arrows if enabled
  if (showDirections) {
    shotGroups.append("line")
      .attr("class", "shot-direction")
      .attr("x1", d => xPitchScale(d.location[0]))
      .attr("y1", d => yPitchScale(d.location[1]))
      .attr("x2", d => xPitchScale(d.location[0] + (d.shot_end_location ? d.shot_end_location[0] - d.location[0] : 0)))
      .attr("y2", d => yPitchScale(d.location[1] + (d.shot_end_location ? d.shot_end_location[1] - d.location[1] : 0)))
      .attr("stroke", d => teamColorScale(d.team))
      .attr("stroke-width", 1)
      .attr("opacity", d => d.shot_outcome === "Goal" ? 0.8 : 0.3)
      .attr("marker-end", "url(#arrow)");
  }

  // Calculate radius based on xG if enabled
  function getRadius(d) {
    if (showXG && d.shot_statsbomb_xg) {
      return Math.sqrt(d.shot_statsbomb_xg) * 15;  // Scale xG for better visibility
    }
    return d.shot_outcome === "Goal" ? 6 : 4;
  }

  // Add shot points
  shotGroups.append("circle")
    .attr("class", "shot-point")
    .attr("cx", d => xPitchScale(d.location[0]))
    .attr("cy", d => yPitchScale(d.location[1]))
    .attr("r", getRadius)
    .attr("fill", d => d.shot_outcome === "Goal" ? teamColorScale(d.team) : "white")  // Only goals get team color fill
    .attr("stroke", d => teamColorScale(d.team))  // All shots get team color stroke
    .attr("stroke-width", d => d.shot_outcome === "Goal" ? 2 : 1.5)
    .attr("opacity", d => d.shot_outcome === "Goal" ? 1 : 0.6)
    .on("mouseover", showShotTooltip)
    .on("mouseout", hideShotTooltip);

  // Add xG legend if enabled
  if (showXG) {
    const legendGroup = window.pitch.append("g")
      .attr("class", "xg-legend")
      .attr("transform", `translate(${width - 100}, 20)`);

    const xgValues = [0.1, 0.3, 0.7];
    
    xgValues.forEach((xg, i) => {
      const y = i * 30 + 10;
      
      legendGroup.append("circle")
        .attr("cx", 0)
        .attr("cy", y)
        .attr("r", Math.sqrt(xg) * 15)
        .attr("fill", "none")
        .attr("stroke", "#666")
        .attr("stroke-width", 1);

      legendGroup.append("text")
        .attr("x", 20)
        .attr("y", y + 5)
        .attr("fill", "#666")
        .style("font-size", "12px")
        .text(`xG: ${xg.toFixed(1)}`);
    });
  } else {
    window.pitch.selectAll(".xg-legend").remove();
  }

  // Update small multiples
  createTeamGoalsMultiples();
}

function showShotTooltip(event, d) {
  const tooltip = d3.select("#shotTooltip");
  
  tooltip.html(`
    <strong>${d.team}</strong><br>
    Player: ${d.player}<br>
    Minute: ${d.minute}'<br>
    Outcome: ${d.shot_outcome}<br>
    Type: ${d.shot_type || 'Open Play'}<br>
    Body Part: ${d.shot_body_part || 'Unknown'}<br>
    ${d.shot_statsbomb_xg ? `xG: ${d.shot_statsbomb_xg.toFixed(2)}` : ''}
  `)
  .style("display", "block");

  // Calculate tooltip position
  const tooltipHeight = tooltip.node().getBoundingClientRect().height;
  const yPosition = event.pageY - tooltipHeight - 10; // Position above cursor
  const xPosition = Math.min(event.pageX + 10, window.innerWidth - tooltip.node().offsetWidth - 20);

  tooltip
    .style("left", xPosition + "px")
    .style("top", yPosition + "px");
}

function hideShotTooltip() {
  d3.select("#shotTooltip").style("display", "none");
}

function createTeamGoalsMultiples() {
  const teams = [...new Set(allEvents.filter(d => 
    d.type === "Shot"
  ).map(d => d.team))];

  // Get sort option
  const sortBy = d3.select('input[name="teamSort"]:checked').property('value');

  // Calculate team stats for sorting
  const teamStats = teams.map(team => {
    const teamShots = allEvents.filter(d => 
      d.type === "Shot" && 
      d.team === team
    );
    
    const goals = teamShots.filter(d => d.shot_outcome === "Goal").length;
    const totalXG = d3.sum(teamShots, d => d.shot_statsbomb_xg || 0);
    const shots = teamShots.length;

    return { 
      team, 
      goals,
      xg: totalXG,
      shots
    };
  });

  // Sort teams based on selected criteria
  teamStats.sort((a, b) => {
    switch(sortBy) {
      case 'xg':
        return b.xg - a.xg;
      case 'shots':
        return b.shots - a.shots;
      default: // goals
        return b.goals - a.goals;
    }
  });

  const sortedTeams = teamStats.map(d => d.team);

  // Get all global filter states (except team filter)
  const showDirections = d3.select('#showDirections').property('checked');
  const showXG = d3.select('#showXG').property('checked');
  const activeTypes = Array.from(document.querySelectorAll('.icon-filter input:checked'))
    .map(input => input.value);

  // Calculate radius based on xG
  function getRadius(d) {
    if (showXG && d.shot_statsbomb_xg) {
      return Math.sqrt(d.shot_statsbomb_xg) * 8;
    }
    return 3;
  }

  // Setup dimensions
  const smallWidth = 180;
  const smallHeight = 140;
  const padding = 60;
  const columns = 3;
  const marginTop = 30;
  
  const totalHeight = Math.ceil(sortedTeams.length / columns) * (smallHeight + padding) + marginTop;
  
  // Clear and reinitialize the SVG
  d3.select("#teamGoalsSvg").selectAll("*").remove();
  const teamGoalsSvg = d3.select("#teamGoalsSvg")
    .attr("width", 900)
    .attr("height", totalHeight);

  // Calculate center offset
  const gridWidth = columns * (smallWidth + padding) - padding;
  const startX = (900 - gridWidth) / 2;

  sortedTeams.forEach((team, i) => {
    const row = Math.floor(i / columns);
    const col = i % columns;
    const x = startX + col * (smallWidth + padding);
    const y = row * (smallHeight + padding) + marginTop;

    const teamG = teamGoalsSvg.append("g")
      .attr("transform", `translate(${x},${y})`);

    // Draw small pitch
    const pitchG = teamG.append("g")
      .attr("class", "small-pitch");

    // Zoom in more on the attacking third (last 30% of pitch)
    const xStart = PITCH_LENGTH * 0.7;  // Start at 70% of pitch length
    const smallXScale = d3.scaleLinear()
      .domain([xStart, PITCH_LENGTH])
      .range([0, smallWidth]);
    
    const smallYScale = d3.scaleLinear()
      .domain([0, PITCH_WIDTH])
      .range([0, smallHeight]);

    // Draw pitch outline with Spain highlight
    pitchG.append("rect")
      .attr("class", `team-goal-area ${team === "Spain" ? "spain-highlight" : ""}`)
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", smallWidth)
      .attr("height", smallHeight)
      .attr("fill", team === "Spain" ? "#fff8f0" : "#f8f8f8")
      .attr("stroke", team === "Spain" ? "#ff4500" : "#ddd")
      .attr("stroke-width", team === "Spain" ? 2 : 1);

    // Draw penalty box
    const boxWidth = smallXScale(PITCH_LENGTH) - smallXScale(PITCH_LENGTH - BOX_LENGTH);
    const boxHeight = smallYScale(BOX_WIDTH);
    pitchG.append("rect")
      .attr("x", smallWidth - boxWidth)
      .attr("y", (smallHeight - boxHeight) / 2)
      .attr("width", boxWidth)
      .attr("height", boxHeight)
      .attr("fill", "none")
      .attr("stroke", "#666");

    // Get filtered goals (ignoring team filter)
    const goals = allEvents.filter(d => {
      if (d.type !== "Shot" || d.shot_outcome !== "Goal" || d.team !== team) return false;
      if (activeTypes.length > 0) {
        const shotTypeMatch = activeTypes.some(type => {
          if (type === "penalty" && d.shot_type === "Penalty") return true;
          if (type === "free_kick" && d.shot_type === "Free Kick") return true;
          if (type === "right_foot" && d.shot_body_part === "Right Foot") return true;
          if (type === "left_foot" && d.shot_body_part === "Left Foot") return true;
          if (type === "header" && d.shot_body_part === "Head") return true;
          return false;
        });
        if (!shotTypeMatch) return false;
      }
      return true;
    });

    // Draw shot directions if enabled
    if (showDirections) {
      teamG.selectAll(".shot-direction")
        .data(goals)
        .join("line")
        .attr("class", "shot-direction")
        .attr("x1", d => smallXScale(d.location[0]))
        .attr("y1", d => smallYScale(d.location[1]))
        .attr("x2", d => smallXScale(d.location[0] + (d.shot_end_location ? d.shot_end_location[0] - d.location[0] : 0)))
        .attr("y2", d => smallYScale(d.location[1] + (d.shot_end_location ? d.shot_end_location[1] - d.location[1] : 0)))
        .attr("stroke", d => teamColorScale(d.team))
        .attr("stroke-width", 1)
        .attr("opacity", d => d.shot_outcome === "Goal" ? 0.8 : 0.3)
        .attr("marker-end", "url(#arrow)");
    }

    // Plot goals
    teamG.selectAll(".goal-point")
      .data(goals)
      .join("circle")
      .attr("class", "goal-point")
      .attr("cx", d => smallXScale(d.location[0]))
      .attr("cy", d => smallYScale(d.location[1]))
      .attr("r", getRadius)
      .attr("fill", teamColorScale(team))
      .attr("stroke", "#fff")
      .attr("stroke-width", 1.5)
      .attr("opacity", 0.9)
      .on("mouseover", showShotTooltip)
      .on("mouseout", hideShotTooltip);

    // Add team label with Spain highlight
    teamG.append("text")
      .attr("class", `team-goal-label ${team === "Spain" ? "spain-highlight" : ""}`)
      .attr("x", smallWidth / 2)
      .attr("y", -15)
      .attr("text-anchor", "middle")
      .text(() => {
        const stats = teamStats.find(s => s.team === team);
        switch(sortBy) {
          case 'xg':
            return `${team} (xG: ${stats.xg.toFixed(1)})`;
          case 'shots':
            return `${team} (${stats.shots} shots)`;
          default:
            return `${team} (${stats.goals} goals)`;
        }
      });

    // Add divider line
    teamG.append("line")
      .attr("x1", 0)
      .attr("x2", smallWidth)
      .attr("y1", -5)
      .attr("y2", -5)
      .attr("stroke", team === "Spain" ? "#ff4500" : "#ddd")
      .attr("stroke-width", team === "Spain" ? 2 : 1);

    // Create hover area
    pitchG.append("rect")
      .attr("class", "team-hover-area")
      .attr("x", 0)
      .attr("y", -20)  // Include team name area
      .attr("width", smallWidth)
      .attr("height", smallHeight + 20)
      .attr("fill", "transparent")
      .style("cursor", "pointer")
      .on("mouseover", (event) => showTeamTooltip(event, team, goals))
      .on("mouseout", () => d3.select("#shotTooltip").style("display", "none"));
  });
}

function getTeamStats(team, goals) {
  // Calculate various stats
  const totalGoals = goals.length;
  const penaltyGoals = goals.filter(d => d.shot_type === "Penalty").length;
  const headerGoals = goals.filter(d => d.shot_body_part === "Head").length;
  const leftFootGoals = goals.filter(d => d.shot_body_part === "Left Foot").length;
  const rightFootGoals = goals.filter(d => d.shot_body_part === "Right Foot").length;
  const avgXG = d3.mean(goals, d => d.shot_statsbomb_xg) || 0;
  
  return `
    <strong>${team}</strong><br>
    Total Goals: ${totalGoals}<br>
    Penalties: ${penaltyGoals}<br>
    Headers: ${headerGoals}<br>
    Left Foot: ${leftFootGoals}<br>
    Right Foot: ${rightFootGoals}<br>
    Avg xG per Goal: ${avgXG.toFixed(2)}
  `;
}

function showTeamTooltip(event, team, goals) {
  const tooltip = d3.select("#shotTooltip");
  tooltip.html(getTeamStats(team, goals))
    .style("display", "block");

  const tooltipHeight = tooltip.node().getBoundingClientRect().height;
  const yPosition = event.pageY - tooltipHeight - 10;
  const xPosition = Math.min(event.pageX + 10, window.innerWidth - tooltip.node().offsetWidth - 20);

  tooltip
    .style("left", xPosition + "px")
    .style("top", yPosition + "px");
}

// Add this at the start of the script, after your existing color definitions
const teamColorScale = d3.scaleOrdinal()
  .domain(["Spain", "England", "France", "Netherlands", "Germany", "Portugal", "Switzerland", "Turkey"])
  .range(["#ff4500", "#3090C7", "#0000FF", "#FFA500", "#000000", "#006400", "#FF0000", "#8B0000"]);

// Add event listener for sort change
d3.selectAll('input[name="teamSort"]').on('change', function() {
  if (this.checked) {
    createTeamGoalsMultiples();
  }
    });

// Add this at the start of your script section
const DATA_URLS = {
  events: "https://storage.googleapis.com/euro2024-data/subset_euro_2024.json",
  players: "https://storage.googleapis.com/euro2024-data/euro2024_players.csv",
  bracket: "https://storage.googleapis.com/euro2024-data/euros-2024-bracket.json",
  standings: "https://storage.googleapis.com/euro2024-data/euros_standing.csv"
};

// Then update all data loading functions:

function loadPlayerData() {
  Promise.all([
    d3.json(DATA_URLS.events),
    d3.csv(DATA_URLS.players)
  ]).then(([eventData, playerData]) => {
    window.playerData = playerData;
    allEvents = eventData;
    updateMarketValueChart();
    updateContributionScatter();
  }).catch(error => {
    console.error("Error loading data:", error);
  });
}

function loadStandingsAndUpdateChart() {
  Promise.all([
    d3.csv(DATA_URLS.players),
    d3.csv(DATA_URLS.standings)
  ]).then(([players, standingsData]) => {
    window.playerData = players;
    standings = standingsData;
    updateMarketValueChart();
  }).catch(error => {
    console.error("Error loading data:", error);
  });
}

function updateMarketValueChart() {
  const width = 900;
  const height = 500;
  const margin = {top: 40, right: 40, bottom: 60, left: 80};
  
  const svg = d3.select("#marketValueSvg")
    .attr("width", width)
    .attr("height", height);
    
  svg.selectAll("*").remove();

  const g = svg.append("g")
    .attr("transform", `translate(${margin.left},${margin.top})`);

  // Add background for Spain's column
  const spainBackground = g.append("rect")
    .attr("class", "spain-highlight-bg")
    .attr("opacity", 0)
    .attr("fill", "#fff8f0");

  // Group and sort players by market value
  const playersByTeam = d3.group(window.playerData, d => d.Country);
  const teamTotalValues = Array.from(playersByTeam, ([team, players]) => ({
    team,
    totalValue: d3.sum(players, p => +p.MarketValue),
    avgValue: d3.mean(players, p => +p.MarketValue),
    standing: standings.find(s => s.Team === team)?.Position || 999,
    players: players.sort((a, b) => +b.MarketValue - +a.MarketValue)
  }));

  // Sort based on selected option
  const sortValue = d3.select('input[name="marketSort"]:checked').property('value');
  if (sortValue === 'value') {
    teamTotalValues.sort((a, b) => b.totalValue - a.totalValue);
  } else {
    teamTotalValues.sort((a, b) => +a.standing - +b.standing);
  }

  const x = d3.scaleBand()
    .domain(teamTotalValues.map(d => d.team))
    .range([0, width - margin.left - margin.right])
    .padding(0.1);

  const y = d3.scaleLinear()
    .domain([0, d3.max(teamTotalValues, d => d.totalValue)])
    .range([height - margin.top - margin.bottom, 0]);

  // Update Spain's background position and size
  spainBackground
    .attr("x", x("Spain"))
    .attr("y", 0)
    .attr("width", x.bandwidth())
    .attr("height", height - margin.top - margin.bottom)
    .transition()
    .duration(500)
    .attr("opacity", 0.3);

  // Create stacked bars for each team
  teamTotalValues.forEach(team => {
    let currentY = 0;
    
    team.players.forEach(player => {
      const value = +player.MarketValue;
      
      g.append("rect")
        .attr("class", "player-bar")
        .attr("x", x(team.team))
        .attr("y", y(currentY + value))
        .attr("width", x.bandwidth())
        .attr("height", y(currentY) - y(currentY + value))
        .attr("fill", teamColorScale(team.team))
        .attr("opacity", team.team === "Spain" ? 1 : 0.7)
        .attr("stroke", team.team === "Spain" ? "#ff4500" : "none")
        .attr("stroke-width", team.team === "Spain" ? 1 : 0)
        .on("mouseover", (event) => {
          // Highlight the bar
          d3.select(event.target)
            .attr("opacity", 1)
            .attr("stroke", "#333")
            .attr("stroke-width", 2);

          // Show tooltip with rich information
          d3.select("#shotTooltip")
            .style("display", "block")
            .html(`
              <div style="background: ${teamColorScale(team.team)}22; padding: 8px; border-radius: 4px;">
                <strong style="color: ${teamColorScale(team.team)}">${player.Name}</strong><br>
                <strong>${team.team}</strong><br>
                Position: ${player.Position}<br>
                Club: ${player.Club}<br>
                Age: ${player.Age}<br>
                Market Value: €${(value/1000000).toFixed(1)}M<br>
                Caps: ${player.Caps} (Goals: ${player.Goals})<br>
                ${player.Foot ? `Preferred Foot: ${player.Foot}<br>` : ''}
                ${player.Height ? `Height: ${player.Height}cm` : ''}
              </div>
            `)
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 10) + "px");
        })
        .on("mouseout", (event) => {
          // Reset bar styling
          d3.select(event.target)
            .attr("opacity", team.team === "Spain" ? 1 : 0.7)
            .attr("stroke", team.team === "Spain" ? "#ff4500" : "none")
            .attr("stroke-width", team.team === "Spain" ? 1 : 0);

          d3.select("#shotTooltip").style("display", "none");
        });
      
      currentY += value;
    });

    // Add team total value label
    g.append("text")
      .attr("x", x(team.team) + x.bandwidth()/2)
      .attr("y", y(team.totalValue) - 5)
      .attr("text-anchor", "middle")
      .attr("fill", team.team === "Spain" ? "#ff4500" : "#666")
      .attr("font-weight", team.team === "Spain" ? "bold" : "normal")
      .style("font-size", "11px")
      .text(`€${(team.totalValue/1000000).toFixed(0)}M`);
  });

  // Add axes
  g.append("g")
    .attr("transform", `translate(0,${height - margin.top - margin.bottom})`)
    .call(d3.axisBottom(x))
    .selectAll("text")
    .attr("transform", "rotate(-45)")
    .style("text-anchor", "end")
    .style("font-weight", d => d === "Spain" ? "bold" : "normal")
    .style("fill", d => d === "Spain" ? "#ff4500" : "#333");

  g.append("g")
    .call(d3.axisLeft(y)
      .tickFormat(d => `€${d/1000000}M`));

  // Add title
  svg.append("text")
    .attr("x", width/2)
    .attr("y", 25)
    .attr("text-anchor", "middle")
    .style("font-size", "16px")
    .style("font-weight", "bold")
    .text(sortValue === 'value' ? 
      "Team Squad Market Value Distribution" : 
      "Team Squad Market Value Distribution (Sorted by Final Standing)");

  // Add y-axis label
  svg.append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", margin.left - 60)
    .attr("x", -(height/2))
    .attr("text-anchor", "middle")
    .style("font-size", "14px")
    .text("Market Value (Millions €)");
}

// Add event listener for sort change
d3.selectAll('input[name="marketSort"]').on('change', function() {
  if (this.checked) {
    updateMarketValueChart();
  }
});

// Update the goToSlide function to load player data
function goToSlide(slideNumber) {
  // Hide current slide
  document.querySelector(`.slide.active`).classList.remove("active");
  
  // Show new slide
  document.querySelector(`#slide${slideNumber}`).classList.add("active");
  
  // Update current slide number
  currentSlide = slideNumber;
  
  // Update navigation
  updateNavigation();

  // Load appropriate data for each slide
  if (slideNumber === 2 && allEvents) {
    renderShotAnalysis();
  } else if (slideNumber === 3) {
    loadPlayerData();
  }
}

function initializePlayerViews() {
  // Set up view switching
  d3.selectAll('input[name="playerView"]').on('change', function() {
    const selectedView = this.value;
    // Hide all views
    d3.selectAll('.view-section').style('display', 'none');
    // Show selected view
    d3.select(`#${selectedView}View`).style('display', 'block');
    
    // Update the appropriate visualization
    switch(selectedView) {
      case 'performance':
        updatePerformanceScatter();
        break;
      case 'market':
        updateMarketValueChart();
        break;
      case 'chemistry':
        updateTeamChemistry();
        break;
    }
  });

  // Show initial view and render market value chart
  d3.select('#marketValueView').style('display', 'block');
  d3.select('#performanceView').style('display', 'none');
  d3.select('#teamChemistryView').style('display', 'none');
  
  // Trigger initial market value chart render
  setTimeout(updateMarketValueChart, 0);
}

// Call this when loading the third slide
if (currentSlide === 3) {
  loadPlayerData();
}

function updateContributionScatter() {
  const width = 800;
  const height = 400;
  const margin = {top: 40, right: 100, bottom: 60, left: 60};
  
  const svg = d3.select("#contributionScatterSvg")
    .attr("width", width)
    .attr("height", height);
    
  svg.selectAll("*").remove();

  const g = svg.append("g")
    .attr("transform", `translate(${margin.left},${margin.top})`);

  // Load only tournament data first
  d3.json(DATA_URLS.events).then(eventData => {
    // Process tournament data
    const playerStats = {};
    
    eventData.forEach(event => {
      if (event.player) {
        if (!playerStats[event.player]) {
          playerStats[event.player] = {
            name: event.player,
            team: event.team,
            goals: 0,
            shots: 0
          };
        }
        if (event.shot_outcome === "Goal") {
          playerStats[event.player].goals += 1;
        }
        if (event.type === "Shot" || event.type === "Goal") {
          playerStats[event.player].shots += 1;
        }
      }
    });

    // Convert to array and filter for players who scored
    const processedData = Object.values(playerStats)
      .filter(d => d.goals > 0);

    // Add team filter
    const teams = [...new Set(processedData.map(d => d.team))].sort();
    
    // Clear and add filter dropdown
    const filterContainer = d3.select("#scatterControls")
      .html("") // Clear existing content
      .style("text-align", "center")
      .style("margin-bottom", "20px");

    filterContainer.append("label")
      .text("Select Team: ")
      .append("select")
      .attr("id", "teamFilter")
      .on("change", updateViz);

    // Add options with Spain first, then others
    d3.select("#teamFilter")
      .selectAll("option")
      .data([...teams]) // Remove "All Teams"
      .enter()
      .append("option")
      .attr("value", d => d)
      .property("selected", d => d === "Spain") // Set Spain as default
      .text(d => d);

    function updateViz() {
      const selectedTeam = d3.select("#teamFilter").property("value");
      const filteredData = processedData.filter(d => d.team === selectedTeam);

      console.log("Filtered data:", filteredData);

      // Create scales
      const x = d3.scaleLinear()
        .domain([0, d3.max(filteredData, d => d.shots) * 1.1])
        .range([0, width - margin.left - margin.right]);

      const y = d3.scaleLinear()
        .domain([0, 5])
        .range([height - margin.top - margin.bottom, 0]);

      // Create a dedicated tooltip for the scatter plot if it doesn't exist
      let scatterTooltip = d3.select("#scatterTooltip");
      if (scatterTooltip.empty()) {
        scatterTooltip = d3.select("body").append("div")
          .attr("id", "scatterTooltip")
          .style("position", "absolute")
          .style("background", "white")
          .style("padding", "10px")
          .style("border", "1px solid #ddd")
          .style("border-radius", "4px")
          .style("pointer-events", "none")
          .style("display", "none")
          .style("box-shadow", "2px 2px 6px rgba(0,0,0,0.1)")
          .style("z-index", "1000");
      }

      // Add points
      const points = g.selectAll(".player-point")
        .data(filteredData, d => d.name);

      points.exit().remove();

      points.enter()
        .append("circle")
        .merge(points)
        .attr("class", "player-point")
        .attr("cx", d => x(d.shots))
        .attr("cy", d => y(d.goals))
        .attr("r", 6)
        .attr("fill", d => teamColorScale(d.team))
        .attr("opacity", 0.7)
        .on("mouseover", function(event, d) {
          d3.select(this)
            .attr("opacity", 1)
            .attr("r", 8)
            .style("stroke", "#333")
            .style("stroke-width", "2px");

          scatterTooltip
            .style("display", "block")
            .html(`
              <div style="
                background: ${teamColorScale(d.team)}22;
                padding: 12px;
                border-radius: 4px;
                min-width: 150px;
              ">
                <div style="
                  font-weight: bold;
                  color: ${teamColorScale(d.team)};
                  margin-bottom: 8px;
                  font-size: 14px;
                ">${d.name}</div>
                <div style="font-size: 13px; line-height: 1.4;">
                  <strong>${d.team}</strong><br>
                  <strong>Goals:</strong> ${d.goals}<br>
                  <strong>Shots:</strong> ${d.shots}<br>
                  <strong>Conversion Rate:</strong> ${((d.goals/d.shots) * 100).toFixed(1)}%
                </div>
              </div>
            `)
            .style("left", `${event.pageX + 12}px`)
            .style("top", `${event.pageY - 10}px`);
        })
        .on("mouseout", function() {
          d3.select(this)
            .attr("opacity", 0.7)
            .attr("r", 6)
            .style("stroke", "none");

          scatterTooltip.style("display", "none");
        });

      // Update axes
      g.selectAll(".axis").remove();

      g.append("g")
        .attr("class", "axis")
        .attr("transform", `translate(0,${height - margin.top - margin.bottom})`)
        .call(d3.axisBottom(x))
        .append("text")
        .attr("x", width - margin.left - margin.right)
        .attr("y", 40)
        .attr("fill", "#666")
        .attr("text-anchor", "end")
        .text("Shots Attempted");

      g.append("g")
        .attr("class", "axis")
        .call(d3.axisLeft(y)
          .ticks(5)
          .tickFormat(d3.format("d")))
        .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 15)
        .attr("dy", ".71em")
        .attr("fill", "#666")
        .attr("text-anchor", "end")
        .text("Goals Scored");
    }

    // Initial visualization
    updateViz();
  });
}
  </script>
</body>
</html>
