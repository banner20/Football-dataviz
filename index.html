<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Football Visualization (Re-draw Approach) - Heatmaps, Goal-Only Assists, Top Scorers</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/d3-hexbin.v0.2.min.js"></script>
  <style>
    body {
      background-color: #021e3f;
      margin: 0; font-family: sans-serif; color: white;
    }
    h1 { text-align: center; margin-top: 1em; }
    #controls {
      width: 800px; margin: 0 auto; text-align: center;
    }
    select, label, button { margin: 0 8px; }
    #pitch {
      display: block; margin: 1em auto;
      background: #01643f; /* pitch color */
      border: 2px solid #fff;
    }
    /* Normal circles/lines */
    .shots-circle { fill: red;     stroke: white; stroke-width: 1; }
    .goals-circle { fill: magenta; stroke: white; stroke-width: 1; }
    .passes-circle{ fill: gold;    stroke: white; stroke-width: 1; }
    .assists-circle{fill: orange;  stroke: white; stroke-width: 1; }
    .shots-line   { stroke: red;     stroke-width: 1.5; opacity: 0.8; }
    .goals-line   { stroke: magenta; stroke-width: 1.5; opacity: 0.8; }
    .passes-line  { stroke: gold;    stroke-width: 1.5; opacity: 0.8; }
    .assists-line { stroke: orange;  stroke-width: 1.5; opacity: 0.8; }

    /* Pitch lines */
    .pitch-line { stroke: white; stroke-width: 2; fill: none; }

    /* Heatmap hex */
    .shots-hex   { fill: red;     }
    .goals-hex   { fill: magenta; }
    .passes-hex  { fill: gold;    }
    .assists-hex { fill: orange;  }

    #stats {
      width: 800px; margin: 1em auto; background: #021e3f;
      border: 1px solid #fff; padding: 1em;
    }
    #stats h2 { margin: 0.5em 0; text-align: center; }
    #stats ul { list-style: none; padding: 0; margin: 0; }
    #stats li { margin: 0.2em 0; cursor: pointer; }
    #stats li:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <h1>Football Visualization (Re-draw) - Heatmaps, Goal-Only Assists, Top Scorers</h1>

  <div id="controls">
    <!-- Team & Player dropdowns -->
    <label>Team:</label>
    <select id="teamSelect">
      <option value="All">All</option>
    </select>
    <label>Player:</label>
    <select id="playerSelect">
      <option value="All">All</option>
    </select>
    <br/><br/>

    <!-- Category toggles -->
    <label><input type="checkbox" id="chkShots"> Shots</label>
    <label><input type="checkbox" id="chkGoals"> Goals</label>
    <label><input type="checkbox" id="chkPasses"> Passes</label>
    <label><input type="checkbox" id="chkAssists"> Goal Assists</label>
    <label><input type="checkbox" id="chkDirections"> Directions</label>
    <br/><br/>

    <!-- Heatmap toggle -->
    <label><input type="checkbox" id="chkHeatmap"> Heatmap Mode</label>
    <br/><br/>

    <!-- Switch View button -->
    <button id="switchViewBtn">Switch View (Full/Rotated Box)</button>
  </div>

  <svg id="pitch" width="800" height="533"></svg>

  <div id="stats">
    <h2>Top Scoring Players</h2>
    <ul id="playerList"></ul>
    <h2>Top Scoring Teams</h2>
    <ul id="teamList"></ul>
  </div>

  <script>
    /***************************************************
     * GLOBALS
     ***************************************************/
    let allData = [];
    let isZoomed = false; // toggles between full pitch & rotated sub-area

    const pitchWidth = 800, pitchHeight=533;
    const svg = d3.select("#pitch");

    // We'll define two scale modes
    const xScale = d3.scaleLinear();
    const yScale = d3.scaleLinear();

    // Full domain
    const fullDomain = {
      xDomain: [0,120],
      yDomain: [0,80],
      xRange:  [0, pitchWidth],
      yRange:  [0, pitchHeight]
    };
    // Rotated penalty box domain
    const rotatedBox = {
      xDomain: [0,44],
      yDomain: [0,18],
      xRange:  [ (800-1302)/2, (800+1302)/2 ], // letterbox horizontally
      yRange:  [ pitchHeight, 0 ]
    };

    // We'll store references to the UI
    const teamSelectEl   = document.getElementById("teamSelect");
    const playerSelectEl = document.getElementById("playerSelect");
    const chkShots       = document.getElementById("chkShots");
    const chkGoals       = document.getElementById("chkGoals");
    const chkPasses      = document.getElementById("chkPasses");
    const chkAssists     = document.getElementById("chkAssists");
    const chkDirections  = document.getElementById("chkDirections");
    const chkHeatmap     = document.getElementById("chkHeatmap");
    const switchViewBtn  = document.getElementById("switchViewBtn");

    const playerList = d3.select("#playerList");
    const teamList   = d3.select("#teamList");

    // We'll define groups for pitch lines
    const gPitchLines = svg.append("g").attr("class","pitch-lines");
    // We'll define separate groups for each category + lines/hex
    // But we'll just re-draw them from scratch, so we can keep it simpler
    // Actually, let's define one group "gAll" to hold everything
    const gAll = svg.append("g").attr("id","allGroups");

    /***************************************************
     * FETCH & PROCESS
     ***************************************************/
    d3.json("subset_bundesliga2.json").then(rawData => {
      // 1) Identify which shots ended in goal => shotMap
      const shotMap = {};
      rawData.forEach(ev => {
        if(ev.type==="Shot" && ev.id) {
          shotMap[ev.id] = ev.shot_outcome;
        }
      });
      // 2) Mark pass => goal if pass_assisted_shot_id references a "Goal"
      rawData.forEach(ev => {
        if(ev.type==="Pass" && ev.pass_assisted_shot_id && shotMap[ev.pass_assisted_shot_id]==="Goal") {
          ev.goal_assist = true;
        }
      });

      allData = rawData;
      initUI(allData);
      computeTopScorers(allData);
      setScales(false); // Full pitch initially
      drawAll(); // initial draw
    })
    .catch(err => console.error("Error loading JSON:", err));

    /***************************************************
     * UI Setup
     ***************************************************/
    function initUI(data) {
      const allTeams   = Array.from(new Set(data.map(d => d.team).filter(Boolean))).sort();
      const allPlayers = Array.from(new Set(data.map(d => d.player).filter(Boolean))).sort();

      allTeams.forEach(t => {
        const opt = document.createElement("option");
        opt.value = t; opt.text = t;
        teamSelectEl.appendChild(opt);
      });
      allPlayers.forEach(p => {
        const opt = document.createElement("option");
        opt.value = p; opt.text = p;
        playerSelectEl.appendChild(opt);
      });

      // Add event listeners
      teamSelectEl.addEventListener("change", drawAll);
      playerSelectEl.addEventListener("change", drawAll);

      [chkShots, chkGoals, chkPasses, chkAssists, chkDirections, chkHeatmap]
        .forEach(chk => chk.addEventListener("change", drawAll));

      switchViewBtn.addEventListener("click", () => {
        isZoomed=!isZoomed;
        setScales(isZoomed);
        drawAll();
      });
    }

    /***************************************************
     * Top Scorers
     ***************************************************/
    function computeTopScorers(data) {
      const goals = data.filter(d => d.type==="Shot" && d.shot_outcome==="Goal");
      // Player-level
      const playerGoals = d3.rollups(goals, v=>v.length, d=>d.player)
        .filter(([p])=>p)
        .sort((a,b)=>d3.descending(a[1], b[1]));
      // Team-level
      const teamGoals = d3.rollups(goals, v=>v.length, d=>d.team)
        .filter(([t])=>t)
        .sort((a,b)=>d3.descending(a[1], b[1]));

      playerList.selectAll("*").remove();
      playerGoals.slice(0,5).forEach(([player,count]) => {
        const li = playerList.append("li").text(`${player}: ${count} goals`);
        li.on("click", () => {
          // Force filter to that player's goals
          teamSelectEl.value="All";
          playerSelectEl.value=player;
          chkShots.checked=false;
          chkPasses.checked=false;
          chkAssists.checked=false;
          chkGoals.checked=true;
          drawAll();
        });
      });

      teamList.selectAll("*").remove();
      teamGoals.slice(0,5).forEach(([team,count]) => {
        const li = teamList.append("li").text(`${team}: ${count} goals`);
        li.on("click", () => {
          teamSelectEl.value=team;
          playerSelectEl.value="All";
          chkShots.checked=false;
          chkPasses.checked=false;
          chkAssists.checked=false;
          chkGoals.checked=true;
          drawAll();
        });
      });
    }

    /***************************************************
     * Scale Setup
     ***************************************************/
    function setScales(zoom) {
      if(!zoom) {
        // Full pitch
        xScale.domain(fullDomain.xDomain).range(fullDomain.xRange);
        yScale.domain(fullDomain.yDomain).range(fullDomain.yRange);
      } else {
        // Rotated penalty box domain
        xScale.domain(rotatedBox.xDomain).range(rotatedBox.xRange);
        yScale.domain(rotatedBox.yDomain).range(rotatedBox.yRange);
      }
    }

    /***************************************************
     * Master Draw
     ***************************************************/
    function drawAll() {
      // Clear everything
      gPitchLines.selectAll("*").remove();
      gAll.selectAll("*").remove();

      // Draw pitch lines
      drawPitchLines();

      // Build category subsets
      const shotsData = allData.filter(d => d.type==="Shot" && d.shot_outcome!=="Goal");
      const goalsData = allData.filter(d => d.type==="Shot" && d.shot_outcome==="Goal");
      const passesData= allData.filter(d => d.type==="Pass" && !d.goal_assist);
      const assistsData= allData.filter(d => d.type==="Pass" && d.goal_assist===true);

      // We'll define a function to filter by team/player
      const selectedTeam   = teamSelectEl.value;
      const selectedPlayer = playerSelectEl.value;
      function passesFilter(ev) {
        if(selectedTeam!=="All" && ev.team!==selectedTeam) return false;
        if(selectedPlayer!=="All" && ev.player!==selectedPlayer) return false;
        return true;
      }

      // Filter each category
      const finalShots   = chkShots.checked   ? shotsData.filter(passesFilter)   : [];
      const finalGoals   = chkGoals.checked   ? goalsData.filter(passesFilter)   : [];
      const finalPasses  = chkPasses.checked  ? passesData.filter(passesFilter)  : [];
      const finalAssists = chkAssists.checked ? assistsData.filter(passesFilter) : [];

      // Draw each category
      drawCategory(finalShots,   "shots",   "red");
      drawCategory(finalGoals,   "goals",   "magenta");
      drawCategory(finalPasses,  "passes",  "gold");
      drawCategory(finalAssists, "assists", "orange");
    }

    function drawCategory(data, classPrefix, color) {
      const showDirections = chkDirections.checked;
      const showHeatmap    = chkHeatmap.checked;

      if(showHeatmap) {
        // Build a hexbin
        const hex = d3.hexbin()
          .radius(12)
          .x(d => xScaleLoc(d.location)[0])
          .y(d => xScaleLoc(d.location)[1])
          .extent([[0,0],[pitchWidth,pitchHeight]]);
        const bins = hex(data);

        const gHex = gAll.append("g").attr("class",`${classPrefix}-hex-group`);
        gHex.selectAll(`.${classPrefix}-hex`)
          .data(bins)
          .enter()
          .append("path")
          .attr("class",`${classPrefix}-hex`)
          .attr("d", hex.hexagon())
          .attr("transform", d => `translate(${d.x},${d.y})`)
          .style("fill", color)
          .style("opacity", d => Math.min(0.2 + d.length*0.05, 1.0));
      } else {
        // Normal circles
        const gCircles = gAll.append("g").attr("class",`${classPrefix}-circles-group`);
        gCircles.selectAll(`.${classPrefix}-circle`)
          .data(data)
          .enter()
          .append("circle")
          .attr("class",`${classPrefix}-circle`)
          .attr("cx", d => xScaleLoc(d.location)[0])
          .attr("cy", d => xScaleLoc(d.location)[1])
          .attr("r",4)
          .attr("fill", color);

        // If Shots/Goals/Passes/Assists have an end_location and showDirections
        if(showDirections) {
          const lineData = data.filter(ev => ev.shot_end_location || ev.pass_end_location);
          const gLines = gAll.append("g").attr("class",`${classPrefix}-lines-group`);
          gLines.selectAll(`.${classPrefix}-line`)
            .data(lineData)
            .enter()
            .append("line")
            .attr("class",`${classPrefix}-line`)
            .attr("x1", d => xScaleLoc(d.location)[0])
            .attr("y1", d => xScaleLoc(d.location)[1])
            .attr("x2", d => {
              const end = d.shot_end_location || d.pass_end_location || d.location;
              return xScaleLoc(end)[0];
            })
            .attr("y2", d => {
              const end = d.shot_end_location || d.pass_end_location || d.location;
              return xScaleLoc(end)[1];
            })
            .attr("stroke", color)
            .attr("stroke-width",1.5)
            .attr("opacity",0.8);
        }
      }
    }

    /***************************************************
     * Draw Pitch Lines
     ***************************************************/
    function drawPitchLines() {
      // Outer boundary
      drawLine(0,0, 120,0);
      drawLine(120,0,120,80);
      drawLine(120,80,0,80);
      drawLine(0,80,0,0);

      // Center line
      drawLine(60,0,60,80);

      // Center circle
      drawCircle(60,40,10);

      // Left penalty box
      drawRect(0,18,18,44);
      // Left 6-yard
      drawRect(0,30,6,20);

      // Right penalty box
      drawRect(102,18,18,44);
      // Right 6-yard
      drawRect(114,30,6,20);

      // Goals
      drawLine(0,36,-2,36);
      drawLine(0,44,-2,44);
      drawLine(120,36,122,36);
      drawLine(120,44,122,44);
    }

    function drawLine(x1,y1,x2,y2) {
      const [X1,Y1] = xScaleLoc([x1,y1]);
      const [X2,Y2] = xScaleLoc([x2,y2]);
      gPitchLines.append("line")
        .attr("x1", X1).attr("y1", Y1)
        .attr("x2", X2).attr("y2", Y2)
        .attr("class","pitch-line");
    }
    function drawRect(x,y,w,h) {
      const c0 = xScaleLoc([x,   y]);
      const c1 = xScaleLoc([x+w, y]);
      const c2 = xScaleLoc([x+w, y+h]);
      const c3 = xScaleLoc([x,   y+h]);
      const path = d3.line()([ c0,c1,c2,c3,c0 ]);
      gPitchLines.append("path")
        .attr("d", path)
        .attr("class","pitch-line");
    }
    function drawCircle(cx,cy,r) {
      const cCenter = xScaleLoc([cx,cy]);
      const cEdge   = xScaleLoc([cx+r,cy]);
      const dist    = Math.hypot(cCenter[0]-cEdge[0], cCenter[1]-cEdge[1]);
      gPitchLines.append("circle")
        .attr("cx", cCenter[0])
        .attr("cy", cCenter[1])
        .attr("r", dist)
        .attr("class","pitch-line");
    }

    // If you want advanced rotation logic, define it in xScaleLoc:
    function xScaleLoc(loc) {
      if(!Array.isArray(loc) || loc.length<2) return [ xScale(60), yScale(40) ];
      const x = loc[0], y = loc[1];
      if(!isZoomed) {
        return [ xScale(x), yScale(y) ];
      } else {
        // Rotated approach => interpret x,y in some manner
        // For simplicity, let's just do domain transforms. 
        // We'll do xScale(x), yScale(y) with the domain we set in setScales.
        return [ xScale(x), yScale(y) ];
      }
    }
  </script>
</body>
</html>
