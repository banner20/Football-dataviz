<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Euro 2024 Goals: Reversed Small Multiples + Direct Match Info</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      background-color: #fafafa;
      font-family: "Open Sans", sans-serif;
      margin: 0; padding: 0;
      color: #333;
    }
    h1 {
      text-align: center;
      margin: 1em 0 0.5em 0;
    }
    #controls {
      width: 900px;
      margin: 0 auto;
      text-align: center;
      margin-bottom: 1em;
    }
    select, input[type=checkbox] {
      margin: 0.5em;
    }
    /* Main timeline container */
    #mainTimelineContainer {
      width: 900px;
      margin: 0 auto;
      position: relative;
    }
    #goalsSvg {
      display: block;
      margin: 0 auto;
      background: #f0f0f0;
      border: 1px solid #ccc;
    }
    .heat-rect {
      stroke: none;
    }
    .goal-circle {
      stroke: #333;
      stroke-width: 1px;
      cursor: pointer;
    }
    .extra-time-line {
      stroke: black;
      stroke-width: 2px;
      stroke-dasharray: 3,3;
    }
    /* Tooltip */
    #tooltip {
      position: absolute;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      padding: 4px 8px;
      pointer-events: none;
      display: none; /* hidden by default */
      font-size: 0.9em;
      z-index: 10; /* ensure on top */
    }
    /* Small multiples container */
    #teamsContainer {
      width: 900px;
      margin: 2em auto;
    }
    .team-chart-bg {
      fill: #eee;
      stroke: #ccc;
      stroke-width: 1px;
    }
    .team-label {
      font-size: 12px;
      text-anchor: start;  /* anchor left side */
      alignment-baseline: middle;
    }
    .mini-heat-rect {
      stroke: none;
    }
  </style>
</head>
<body>

<h1>Euro 2024 Goals Visualization</h1>

<div id="controls">
  <label>Team Filter:</label>
  <select id="teamSelect"></select>

  <label>
    <input type="checkbox" id="penaltyCheck" />
    Exclude Penalty Goals
  </label>

  <label>
    <input type="checkbox" id="miniHeatCheck" />
    Heatmap in Small Multiples
  </label>
</div>

<div id="mainTimelineContainer">
  <svg id="goalsSvg" width="900" height="300"></svg>
  <div id="tooltip"></div>
</div>

<div id="teamsContainer"></div>

<script>
/**
 * We'll load subset_euro_2024.json:
 *  - Filter for shot_outcome == "Goal".
 *  - For each event, we assume fields:
 *    d.player -> the scorer
 *    d.home_team, d.away_team -> teams playing
 *    d.home_score, d.away_score -> final scores
 *    shot_type -> "Penalty" or something else
 *  - We'll clamp timeInMin in [0..130] for binning, domain extends -5..135
 *  - Exclude Penalty is ON by default
 *  - We have small multiples sorted by total goals, each row reversed horizontally
 */

const svg = d3.select("#goalsSvg");
const tooltip = d3.select("#tooltip");
const width = +svg.attr("width");
const height = +svg.attr("height");

const margin = { top: 20, right: 20, bottom: 30, left: 40 };
const innerWidth = width - margin.left - margin.right;
const innerHeight = height - margin.top - margin.bottom;

const gMain = svg.append("g")
  .attr("transform", `translate(${margin.left},${margin.top})`);

// We'll define an extended domain: e.g. -5..135
const xDomain = [-5, 135];
const xScale = d3.scaleLinear()
  .domain(xDomain)
  .range([0, innerWidth]);

// Center for circles in main chart
const yCenter = innerHeight / 2;

// We'll store allGoals, allTeams
let allGoals = [];
let allTeams = [];

// DOM references for filters
const teamSelectEl = document.getElementById("teamSelect");
const penaltyCheckEl = document.getElementById("penaltyCheck");
const miniHeatCheckEl = document.getElementById("miniHeatCheck");

// Set "Exclude Penalty Goals" ON by default
penaltyCheckEl.checked = true;

let teamsSvg; // we'll build once for small multiples

// 1) Load data
d3.json("subset_euro_2024.json").then(events => {
  // Filter for shot_outcome = "Goal"
  const goals = events.filter(d => d.type === "Shot" && d.shot_outcome === "Goal");

  // For each, compute timeInMin + clamp for binning in [0..130]
  goals.forEach(d => {
    const rawTime = (d.minute || 0) + ((d.second||0)/60);
    d.clampedMinute = Math.max(0, Math.min(130, rawTime));
    d.timeInMin = rawTime; // can display up to 135
  });

  // Build set of teams
  const teamSet = new Set(goals.map(d => d.team));
  allTeams = Array.from(teamSet).sort();

  // Populate <select>
  let optAll = document.createElement("option");
  optAll.value = "All";
  optAll.text = "All Teams";
  teamSelectEl.appendChild(optAll);

  allTeams.forEach(t => {
    const opt = document.createElement("option");
    opt.value = t;
    opt.text = t;
    teamSelectEl.appendChild(opt);
  });

  allGoals = goals;

  // Build small multiples container
  buildTeamSmallMultiples();

  // Attach listeners => re-draw main timeline + small multiples
  teamSelectEl.addEventListener("change", updateAll);
  penaltyCheckEl.addEventListener("change", updateAll);
  miniHeatCheckEl.addEventListener("change", updateAll);

  // Initial draw
  updateAll();
});


function updateAll() {
  // Re-draw main timeline + small multiples
  updateMainChart();
  updateTeamSmallMultiples();
}


/**
 * updateMainChart():
 *  - Applies team filter + penalty filter
 *  - Re-draws heatmap bins + circles
 */
function updateMainChart() {
  gMain.selectAll("*").remove();

  const selectedTeam = teamSelectEl.value;
  const excludePen = penaltyCheckEl.checked;

  // Filter
  let filtered = allGoals;
  if(selectedTeam !== "All") {
    filtered = filtered.filter(d => d.team === selectedTeam);
  }
  if(excludePen) {
    filtered = filtered.filter(d => d.shot_type !== "Penalty");
  }

  // Build bins for minuteCounts[0..130]
  const minuteCounts = new Array(131).fill(0);
  filtered.forEach(d => {
    const m = Math.floor(d.clampedMinute);
    minuteCounts[m]++;
  });
  const maxCount = d3.max(minuteCounts) || 0;

  // Color scale for heatmap
  const heatColor = d3.scaleLinear()
    .domain([0, maxCount])
    .range(["#ffffff", "#ff4500"]);

  // We'll create 131 bins => i=0..130
  const binWidth = xScale(1) - xScale(0);

  // 1) Heatmap
  gMain.selectAll(".heat-rect")
    .data(minuteCounts)
    .enter().append("rect")
      .attr("class", "heat-rect")
      .attr("x", (count, i) => xScale(i))
      .attr("y", 0)
      .attr("width", binWidth+0.5)
      .attr("height", innerHeight)
      .attr("fill", c => heatColor(c));

  // 2) X-axis
  const xAxis = d3.axisBottom(xScale)
    .tickFormat(d => d + "'")
    .ticks(14);
  gMain.append("g")
    .attr("transform", `translate(0,${innerHeight})`)
    .call(xAxis);

  // 3) Vertical line at 90
  const x90 = xScale(90);
  gMain.append("line")
    .attr("class", "extra-time-line")
    .attr("x1", x90)
    .attr("y1", 0)
    .attr("x2", x90)
    .attr("y2", innerHeight);

  // 4) Circles
  const colorScale = d3.scaleOrdinal()
    .domain(allTeams)
    .range(d3.schemeCategory10);

  gMain.selectAll(".goal-circle")
    .data(filtered)
    .enter().append("circle")
      .attr("class", "goal-circle")
      .attr("cx", d => xScale(d.timeInMin))
      .attr("cy", () => (innerHeight/2) + (Math.random()*10 - 5))
      .attr("r", 5)
      .attr("fill", d => colorScale(d.team))
      .on("mouseover", (event, d) => {
        showTooltip(event, d);
      })
      .on("mouseout", hideTooltip);
}


/**
 * buildTeamSmallMultiples():
 *  Creates an empty SVG for small multiples. We'll re-build rows on each update.
 */
function buildTeamSmallMultiples() {
  const container = d3.select("#teamsContainer");
  container.selectAll("*").remove();

  // We'll create a single <svg> for the small multiples
  teamsSvg = container.append("svg")
    .attr("id", "teamsSvg");
}


/**
 * updateTeamSmallMultiples():
 *  - Sort teams by total goals desc
 *  - Re-build rows in that order
 *  - Each row: label on left, circles on the RIGHT side => reversed x-scale
 */
function updateTeamSmallMultiples() {
  teamsSvg.selectAll("*").remove();

  const excludePen = penaltyCheckEl.checked;
  const showHeatInMini = miniHeatCheckEl.checked;

  // Count goals per team under current filters
  let teamGoalsCount = [];
  allTeams.forEach(team => {
    let tg = allGoals.filter(d => d.team === team);
    if(excludePen) {
      tg = tg.filter(d => d.shot_type !== "Penalty");
    }
    const total = tg.length;
    teamGoalsCount.push({ team, total });
  });
  // Sort desc
  teamGoalsCount.sort((a, b) => d3.descending(a.total, b.total));

  const chartWidth = 800, chartHeight = 60, spacing=10;
  const totalHeight = teamGoalsCount.length*(chartHeight+spacing)+20;
  teamsSvg
    .attr("width", chartWidth+60)
    .attr("height", totalHeight);

  // We'll define a reversed x-scale for the small multiples:
  // minute=0 => right edge, minute=130 => left edge
  const xScaleRev = d3.scaleLinear()
    .domain([0,130])
    .range([chartWidth-50, 0]); // reversed

  // color scale for circles
  const colorScale = d3.scaleOrdinal()
    .domain(allTeams)
    .range(d3.schemeCategory10);

  teamGoalsCount.forEach((obj, i) => {
    const { team, total } = obj;
    const yOffset = i*(chartHeight+spacing)+10;

    const subG = teamsSvg.append("g")
      .attr("transform", `translate(50,${yOffset})`);

    // background
    subG.append("rect")
      .attr("class", "team-chart-bg")
      .attr("width", chartWidth-50)
      .attr("height", chartHeight)
      .attr("x", 0)
      .attr("y", 0);

    // label => "TeamName (X goals)", anchored on the left
    subG.append("text")
      .attr("class", "team-label")
      .attr("x", 0) // left side
      .attr("y", chartHeight/2)
      .text(`${team} (${total} goals)`);

    // filter the actual goals for this team
    let rowGoals = allGoals.filter(d => d.team === team);
    if(excludePen) {
      rowGoals = rowGoals.filter(d => d.shot_type !== "Penalty");
    }

    // optional heatmap
    if(showHeatInMini) {
      const minuteCounts = new Array(131).fill(0);
      rowGoals.forEach(d => {
        const m = Math.floor(d.clampedMinute);
        minuteCounts[m]++;
      });
      const maxCount = d3.max(minuteCounts) || 0;
      const heatColor = d3.scaleLinear()
        .domain([0, maxCount])
        .range(["#ffffff", "#ff4500"]);

      const binWidth = xScaleRev(129) - xScaleRev(130); 
      // e.g. xScaleRev(129) might be > xScaleRev(130) => negative
      // We'll take the abs
      const binW = Math.abs(binWidth);

      subG.selectAll(".mini-heat-rect")
        .data(minuteCounts)
        .enter().append("rect")
          .attr("class", "mini-heat-rect")
          .attr("x", (count, i) => xScaleRev(i) - binW) // shift by bin width
          .attr("y", 0)
          .attr("width", binW+0.5)
          .attr("height", chartHeight)
          .attr("fill", c => heatColor(c));
    }

    // Now circles
    const yCenter = chartHeight/2;
    subG.selectAll(".team-goal")
      .data(rowGoals)
      .enter().append("circle")
        .attr("class", "team-goal")
        .attr("r", 4)
        .attr("fill", colorScale(team))
        .attr("cx", d => xScaleRev(d.timeInMin))
        .attr("cy", () => yCenter + (Math.random()*6 - 3))
        .on("mouseover", (event, d) => {
          showTooltip(event, d);
        })
        .on("mouseout", hideTooltip);
  });
}


/**
 * showTooltip(event, d):
 *  - Positions the tooltip near the cursor
 *  - If near right edge, shift left
 *  - Content includes team, minute, match info from event data
 *    We assume:
 *      d.player -> scorer
 *      d.home_team, d.away_team -> e.g. "Switzerland", "Belgium"
 *      d.home_score, d.away_score -> final numeric scores
 */
function showTooltip(event, d) {
  // Attempt to build match label from the event itself
  const home = d.home_team || "HomeTeam";
  const away = d.away_team || "AwayTeam";
  const matchLabel = `${home} vs ${away}`;

  // final score
  const homeSc = (d.home_score != null) ? d.home_score : "?";
  const awaySc = (d.away_score != null) ? d.away_score : "?";
  const finalScore = `${homeSc}-${awaySc}`;

  const scorer = d.player || "Unknown Scorer";

  const content = `
    <strong>${d.team}</strong><br>
    Minute: ${d.timeInMin.toFixed(1)}<br>
    Match: ${matchLabel}<br>
    Final Score: ${finalScore}<br>
    Scorer: ${scorer}
  `;
  tooltip.html(content);

  let leftPos = event.pageX + 10;
  let topPos = event.pageY - 20;

  tooltip.style("display", "block")
    .style("left", leftPos + "px")
    .style("top", topPos + "px");

  const tipNode = tooltip.node();
  const tipWidth = tipNode.offsetWidth || 150;
  const tipHeight = tipNode.offsetHeight || 50;

  // If going off right edge
  if(leftPos + tipWidth > window.innerWidth) {
    leftPos = window.innerWidth - tipWidth - 10;
  }
  // If going off top
  if(topPos < 0) {
    topPos = 10;
  }
  tooltip.style("left", leftPos + "px")
         .style("top", topPos + "px");
}

function hideTooltip() {
  tooltip.style("display", "none");
}
</script>
</body>
</html>
